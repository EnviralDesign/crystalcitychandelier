void writeToLeds(int t0, int t1, int t2, int t3, int t4, int t5, int t6, int t7, int t8) { // arguments: 1 = enable teensy in this thread, 0 = not.
   timeCapture1 = millis();
  
  image(movie_A, 0, 0); // load movie a, the clip we eventually transition OUT of.
  loadPixels(); // Load raw pixel data into standard pixel array.
  pixelArray_A = pixels; // save raw pixel array to our pixel array associated with movieA
  
  // For each pixel in the image (width * height) 
  for(int pix = 0; pix < (width*height); pix++){
    color c = pixelArray_A[pix]; // grab pixels color into color object.
    // Using bit shifting, the next three lines split values into rgb 0-255 
    int r = (int) (((c >> 16) & 0xFF) * maxBright);
    int g = (int) (((c >> 8) & 0xFF) * maxBright);
    int b = (int) ((c & 0xFF) * maxBright);
    // here we asssign our rgb data into our byte array while converting it to bytes. byte order: r1,g1,b1,r2,g2,b2, etc... 
    vals_A[pix * dataChunkSize] = (int) r;
    vals_A[pix * dataChunkSize+1] = (int) g;
    vals_A[pix * dataChunkSize+2] = (int) b;
  }
  
  
  image(movie_B, 0, 0); // load movie b, the clip we eventually transition IN to.
  loadPixels(); // Load raw pixel data into standard pixel array.
  pixelArray_B = pixels; // save raw pixel array to our pixel array associated with movieB
  
  // For each pixel in the image (width * height) 
  for(int pix = 0; pix < (width*height); pix++){
    color c = pixelArray_B[pix]; // grab pixels color into color object.
    // Using bit shifting, the next three lines split values into rgb 0-255 
    int r = (int) (((c >> 16) & 0xFF) * maxBright);
    int g = (int) (((c >> 8) & 0xFF) * maxBright);
    int b = (int) ((c & 0xFF) * maxBright);
    // here we asssign our rgb data into our byte array while converting it to bytes. byte order: r1,g1,b1,r2,g2,b2, etc... 
    vals_B[pix * dataChunkSize] = (int) r;
    vals_B[pix * dataChunkSize+1] = (int) g;
    vals_B[pix * dataChunkSize+2] = (int) b;
  }
  
  
  
  // NOTE: for 98% of the time, we will only see video A playing. however to smoothly transition to B, we need a way to cross fade into B towards the end of A's time frame.
  //       To do this, the above for loops load video a and b into two separate pixel arrays EVERY frame. We need to procedurally blend between the two arrays when the time
  ///      is right. We do this below. 
  
  // We start over, iterating through every pixel in our image.
  for(int pix = 0; pix < (width*height); pix++){
    
    // Here we blend the two pixel arrays procedurally using math and averaging in conjunction with a normalized tween var that is maintained in the videoManagerTab.
    // Breakdown:      ( A * ( 1 - crossFadeNormalized ) )    +    ( B * crossFadeNormalized )
    int r = (int)( (((float)vals_A[pix*dataChunkSize  ]) * (1-t_normalized)) + (((float)vals_B[pix*dataChunkSize  ]) * t_normalized) );
    int g = (int)( (((float)vals_A[pix*dataChunkSize+1]) * (1-t_normalized)) + (((float)vals_B[pix*dataChunkSize+1]) * t_normalized) );
    int b = (int)( (((float)vals_A[pix*dataChunkSize+2]) * (1-t_normalized)) + (((float)vals_B[pix*dataChunkSize+2]) * t_normalized) );
    
    
    pixels[pix] = color(r, g, b);
    
    // teensyIterator rounds down to the teensy number currently being worked on. this is generated by dividing by 1200, the total number of led's per teensy. Simply
    // a procedural way of doing it based off of our for loop. 1200 is significant because it is the number of led's per teensy.
    teensyIterator = pix / 1200;
    
    
    // Based on teensyIterator, we assign r/g/b values from the pixel array to the corresponding rgb values array.
    // (1200 * teensyIterator) keeps the value array from going out of bounds, while the parent for loop is pulling the appropriate color values from the pixel array.
    if(teensyIterator == 0){
      vals_0[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_0[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_0[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 1){
      vals_1[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_1[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_1[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 2){
      vals_2[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_2[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_2[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 3){
      vals_3[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_3[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_3[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 4){
      vals_4[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_4[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_4[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 5){
      vals_5[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_5[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_5[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 6){
      vals_6[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_6[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_6[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 7){
      vals_7[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_7[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_7[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 8){
      vals_8[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_8[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_8[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    
    updatePixels();
  }
  
    
  timeCapture2 = millis();

  // Based on the ints passed into this argument, we send the data over serial to the teensys or we dont. 
  // This is the most costly part of the script, and the one that is delegated to other processing threads if needed.
  if(t0 == 1){ teensy_0.write(vals_0); }
  if(t1 == 1){ teensy_1.write(vals_1); }
  if(t2 == 1){ teensy_2.write(vals_2); }
  if(t3 == 1){ teensy_3.write(vals_3); }
  if(t4 == 1){ teensy_4.write(vals_4); }
  if(t5 == 1){ teensy_5.write(vals_5); }
  if(t6 == 1){ teensy_6.write(vals_6); }
  if(t7 == 1){ teensy_7.write(vals_7); }
  if(t8 == 1){ teensy_8.write(vals_8); }
  
  /*
  */

}


