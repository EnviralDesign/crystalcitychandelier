import processing.video.*;
import processing.serial.*;

//// --- USER EDITABLE VARIABLES: ---
// Data variables:
String[] ports = {"COM8","COM10","COM14","COM15","COM16","COM17","COM18","COM19","COM20"};

int rows = 150;
int columns = 72;
int dataChunkSize = 3;

// Art variables:
float maxBright = .5;
//// ---------------------------------

//// --- INITIALIZATION VARIABLES: ---

int totalLedCount = rows*columns;
Movie myMovie;

boolean captureTime = true;
int frameTimeReportIters = 60;
int frameTimeReportCounter = 0;
int frameTimeCumulativeHolder = 0;
int frameTime_first = 0;
int frameTime_second = 0;
int frameTime_third = 0;
int obligatoryDelay = 2;
int timeCapture0;
int timeCapture1;
int timeCapture2;
int timeCapture3;

int teensyIterator = 0;

// Serial Objects - Per Teensy
Serial teensy_0;
Serial teensy_1;
Serial teensy_2;
Serial teensy_3;
Serial teensy_4;
Serial teensy_5;
Serial teensy_6;
Serial teensy_7;
Serial teensy_8;

// Teensy rgb byte arrays - per teensy
byte[] vals_0 = new byte[(totalLedCount/9) * dataChunkSize];
byte[] vals_1 = new byte[(totalLedCount/9) * dataChunkSize];
byte[] vals_2 = new byte[(totalLedCount/9) * dataChunkSize];
byte[] vals_3 = new byte[(totalLedCount/9) * dataChunkSize];
byte[] vals_4 = new byte[(totalLedCount/9) * dataChunkSize];
byte[] vals_5 = new byte[(totalLedCount/9) * dataChunkSize];
byte[] vals_6 = new byte[(totalLedCount/9) * dataChunkSize];
byte[] vals_7 = new byte[(totalLedCount/9) * dataChunkSize];
byte[] vals_8 = new byte[(totalLedCount/9) * dataChunkSize];

// date and time init vars:
int s = second();  // Values from 0 - 59
int mi = minute();  // Values from 0 - 59
int h = hour();    // Values from 0 - 23
int d = day();    // Values from 1 - 31
int mo = month();  // Values from 1 - 12
int y = year();   // 2003, 2004, 2005, etc.

long epoch = 0;



//// ---------------------------------

public void setup() {
  
  // size and frame rate
  size(rows, columns);
  frameRate(60);
  
  // Print out all available serial ports
  println(Serial.list());
  
  // Instantiate serial ports per teensy
  teensy_0 = new Serial(this, ports[0], 115200);
  teensy_1 = new Serial(this, ports[1], 115200);
  teensy_2 = new Serial(this, ports[2], 115200);
  teensy_3 = new Serial(this, ports[3], 115200);
  teensy_4 = new Serial(this, ports[4], 115200);
  teensy_5 = new Serial(this, ports[5], 115200);
  teensy_6 = new Serial(this, ports[6], 115200);
  teensy_7 = new Serial(this, ports[7], 115200);
  teensy_8 = new Serial(this, ports[8], 115200);
  
  delay(500);

  // Initiate the the video sequence 
  myMovie = new Movie(this, "testRamps.mov");
  myMovie.loop();
  
}


void draw() {
  
  s = second();  // Values from 0 - 59
  mi = minute();  // Values from 0 - 59
  h = hour();    // Values from 0 - 23
  d = day();    // Values from 1 - 31
  mo = month();  // Values from 1 - 12
  y = year();   // 2003, 2004, 2005, etc.
  
  // Capturing time 0 for frame rate calculation..
  if(captureTime){
    timeCapture0 = millis();
  }
  
  // place movie file on canvas (must happen every frame, small method below controls playback)
  image(myMovie, 0, 0);
  loadPixels(); // Load canvas pixels into pixel array / memory.

  // Capturing time 1 for frame rate calculation..
  if(captureTime){
    timeCapture1 = millis();
  }
  
  
  /*
  
  // iterate through all pixels in pixel array
  for(int pix = 0; pix < (width*height); pix++){
   
   // grab pixel color from array and assign to c - color variable.
    color c = pixels[pix];
    
    // Using bit shifting, split values into rgb 0-255 
    int r = (int) (((c >> 16) & 0xFF) * maxBright);
    int g = (int) (((c >> 8) & 0xFF) * maxBright);
    int b = (int) ((c & 0xFF) * maxBright);
    
    // teensyIterator rounds down to the teensy number currently being worked on. this is generated by dividing by 1200, the total number of led's per teensy.
    teensyIterator = pix / 1200;
    
    // Based on teensyIterator, we assign r/g/b values from the pixel array to the corresponding rgb values array.
    // (1200 * teensyIterator) keeps the value array from going out of bounds, while the parent for loop is pulling the appropriate color values from the pixel array.
    if(teensyIterator == 0){
      vals_0[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_0[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_0[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 1){
      vals_1[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_1[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_1[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 2){
      vals_2[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_2[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_2[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 3){
      vals_3[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_3[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_3[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 4){
      vals_4[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_4[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_4[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    if(teensyIterator == 5){
      vals_5[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_5[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_5[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 6){
      vals_6[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_6[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_6[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 7){
      vals_7[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_7[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_7[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
    else if(teensyIterator == 8){
      vals_8[(pix - (1200 * teensyIterator))*dataChunkSize] = (byte) r;
      vals_8[(pix - (1200 * teensyIterator))*dataChunkSize+1] = (byte) g;
      vals_8[(pix - (1200 * teensyIterator))*dataChunkSize+2] = (byte) b;
    }
  }
  
  // Capturing time 2 for frame rate calculation..
  if(captureTime){
    timeCapture2 = millis();
  }
 
   // Write rgb value arrays to all teensy ports.
   teensy_0.write(vals_0);
   teensy_1.write(vals_1);
   teensy_2.write(vals_2);
   teensy_3.write(vals_3);
   teensy_4.write(vals_4);
   teensy_5.write(vals_5);
   teensy_6.write(vals_6);
   teensy_7.write(vals_7);
   teensy_8.write(vals_8);
   
   */
   
   writeToLeds(12);

  // If capture time is true, we print out our debug info. set captureTime to false above once script is ready to go into performance mode.
  if(captureTime){
    timeCapture3 = millis();
    frameTimeCumulativeHolder += (timeCapture3 - timeCapture0);
    frameTime_first += (timeCapture1 - timeCapture0);
    frameTime_second += (timeCapture2 - timeCapture1);
    frameTime_third += (timeCapture3 - timeCapture2);
    if(frameTimeReportCounter <= 0){
      frameTimeReportCounter = frameTimeReportIters;
      println("");
      println("");
      println("");
      print("Cooktime for 60 Frames: ");
      println(frameTimeCumulativeHolder);
      print("Cooktime for single Frame: ");
      println(frameTimeCumulativeHolder / frameTimeReportIters);
      println("-----------------");
      print("Gif Processing: ");
      print(String.format("%.1f", ((float)frameTime_first / (float)frameTimeCumulativeHolder) * 100));
      println(" %");
      print("Pixel Access: ");
      print(String.format("%.1f", ((float)frameTime_second / (float)frameTimeCumulativeHolder) * 100));
      println(" %");
      print("Serial Send: ");
      print(String.format("%.1f", ((float)frameTime_third / (float)frameTimeCumulativeHolder) * 100));
      println(" %"); 
      println("-----------------");
      // y,mo,d,h,mi,s
      //epoch = s + (mi*60) + (h * 3600) + (d * 86400) + ((y - 70) * 31536000) + (((y - 69)/4) * 86400) - (((y-1)/100)*86400) + (((y+299)/400)*86400);
      epoch = System.currentTimeMillis()/1000;
      print("Time since Epoch: ");
      println(epoch);
      
      
      frameTimeCumulativeHolder = 0;
      frameTime_first = 0;
      frameTime_second = 0;
      frameTime_third = 0;
    }
  frameTimeReportCounter -= 1;
  }
}

// Called every time a new frame is available to read
void movieEvent(Movie m) {
  m.read();
}
